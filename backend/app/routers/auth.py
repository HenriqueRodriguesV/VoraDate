from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, EmailStr
from passlib.context import CryptContext
import os

import oracledb  # <-- Oracle DB driver

from app.models.user import UserOut

router = APIRouter(tags=["Auth"])

# ---------- CONFIG ORACLE (via .env) ----------
ORACLE_USER = os.getenv("ORACLE_USER")
ORACLE_PASSWORD = os.getenv("ORACLE_PASSWORD")
ORACLE_DSN = os.getenv("ORACLE_DSN")  # ex: "host:porta/servicename"

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


# ---------- MODELOS ----------

class RegisterRequest(BaseModel):
    email: EmailStr
    senha: str


class LoginRequest(BaseModel):
    email: EmailStr
    senha: str


# ---------- CONEXÃO COM ORACLE ----------

def get_conn():
    """
    Abre conexão com o Oracle usando python-oracledb em modo thin.
    Certifique-se que ORACLE_USER, ORACLE_PASSWORD, ORACLE_DSN estão no .env
    """
    if not ORACLE_USER or not ORACLE_PASSWORD or not ORACLE_DSN:
        raise RuntimeError("Configuração ORACLE_* ausente no .env")

    return oracledb.connect(
        user=ORACLE_USER,
        password=ORACLE_PASSWORD,
        dsn=ORACLE_DSN,
    )


def init_db():
    """
    Cria tabela USERS se não existir.
    Usa bloco PL/SQL para ignorar erro de 'table already exists' (ORA-00955).
    """
    conn = get_conn()
    cur = conn.cursor()
    cur.execute(
        """
        BEGIN
            EXECUTE IMMEDIATE '
                CREATE TABLE users (
                    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    email VARCHAR2(255) UNIQUE NOT NULL,
                    password_hash VARCHAR2(255) NOT NULL
                )
            ';
        EXCEPTION
            WHEN OTHERS THEN
                IF SQLCODE != -955 THEN
                    RAISE;
                END IF;
        END;
        """
    )
    conn.commit()
    cur.close()
    conn.close()


# cria tabela na importação
init_db()


# ---------- ROTAS ----------

@router.post("/register", response_model=UserOut)
async def register(payload: RegisterRequest):
    """Cadastro de usuário: grava email + hash da senha no Oracle."""
    if len(payload.senha) < 8:
        raise HTTPException(status_code=400, detail="A senha deve ter pelo menos 8 caracteres.")
    if len(payload.senha) > 72:
        raise HTTPException(status_code=400, detail="A senha deve ter no máximo 72 caracteres.")

    password_hash = pwd_context.hash(payload.senha)

    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute(
            "INSERT INTO users (email, password_hash) VALUES (:1, :2)",
            (payload.email, password_hash),
        )
        conn.commit()

        # pega o id gerado
        cur.execute("SELECT id FROM users WHERE email = :1", (payload.email,))
        row = cur.fetchone()

        cur.close()
        conn.close()
    except oracledb.IntegrityError as e:
        # ORA-00001: unique constraint violated
        error_obj, = e.args
        if error_obj.code == 1:
            raise HTTPException(status_code=400, detail="E-mail já cadastrado.")
        raise HTTPException(status_code=500, detail="Erro de integridade no banco.")
    except Exception as e:
        print("Erro ao registrar usuário (Oracle):", e)
        raise HTTPException(status_code=500, detail="Erro ao registrar usuário.")

    user_id = row[0] if row else None
    return UserOut(id=user_id, email=payload.email)


@router.post("/login")
async def login(payload: LoginRequest):
    """Login: compara senha enviada com o hash salvo no Oracle."""
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute(
            "SELECT id, email, password_hash FROM users WHERE email = :1",
            (payload.email,),
        )
        row = cur.fetchone()
        cur.close()
        conn.close()
    except Exception as e:
        print("Erro ao consultar usuário (Oracle):", e)
        raise HTTPException(status_code=500, detail="Erro ao consultar usuário.")

    if not row:
        raise HTTPException(status_code=401, detail="Credenciais inválidas.")

    user_id, email, password_hash = row

    if not pwd_context.verify(payload.senha, password_hash):
        raise HTTPException(status_code=401, detail="Credenciais inválidas.")

    return {
        "ok": True,
        "message": "Login bem sucedido!",
        "user": {"id": user_id, "email": email},
    }
